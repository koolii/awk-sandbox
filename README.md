# awk-sandbox

## 真偽
* 数字のゼロは「偽」
* 空の文字列は「偽」
* 上記以外は全て「真」

## 基本形

`awk パターン {アクション}`

↑のような構造になっており、それぞれ省略することが可能
* パターンを省略した場合には全てのレコードに対してアクションを実行
* アクションが省略された場合にはパターンにマッチしたレコードを表示する
* どちらも省略した場合には何も表示されない

## メモ
* シングルクォート　 -> 内容を文字列として出力
* ダブルクォート -> 変数の内容を文字列として出力
* バッククォート 　-> コマンドとして実行して結果を出力
* Cライクな文法で統一して記述できる
* 他のコマンドに頼ることなくすべてをAWKだけで完結出来る
* 処理が早い
* 「型がない」「配列と連想配列が同じ」といったことは、面倒なことを意識させないというAWKの思想の一つ

### TODO
7章から10章まではGNU AWKの説明であまり興味が無いので、通常のAWKで満足できなくなったりしたら勉強する

## 11章(src/commands)
### レコードとフィールド
AWKはテキストファイルをレコードとフィールドに分割する。
「レコードはレコードセパレータRSで分割した単位であり、必ず分割されるもの」
「フィールドはレコードをフィールドセパレータFSで分割した単位であり、必要に応じて分割されるもの」

これはフィールドが自動で分割されない例で、出力のフィールドの区切りはスペースのまま。
これはレコードの中がフィールドに分割されていないため。
$ echo 'a b c d' | awk 'BEGIN {OPS = ","} {print $0}'
a b c d

フィールドの分割は、フィルドに対し何らかの操作を行った時に初めて行われる
この時によくやる何らかの操作は「$1 = $1」を使ったフィールドの再構築
$ echo 'a b c d' | awk 'BEGIN {OPS = ","} {$1 = $1; print $0}'
a,b,c,d

### cutコマンド

第三フィールドを抜き出すcut/awkコマンド
```bash
$ echo 'a b c d' | cut -d ' ' -f 3
$ echo 'a b c d' | awk '{print $3}'
c
```

cutコマンドは範囲を指定してフィールドを抜き出すことができる
第二フィールドから第四フィールドまでを抜き出す
AWKは特定の範囲のフィールドを抜き出すのは非常に面倒になってしまう
しかも、末尾には出力の末尾にスペースが入るという問題がある
```bash
echo 'a b c d' | cut -d ' ' -f '2-4'
b c d
echo 'a b c d' | awk '{for (i=2; i<=4; i++) { printf("%s ", $i); }} END { print "" }'
b c d
```


